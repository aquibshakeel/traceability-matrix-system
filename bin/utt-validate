#!/usr/bin/env node
/**
 * Unit-Test-Tracer CLI - Standalone validation tool
 * 
 * Usage:
 *   utt-validate                    # Validate all services
 *   utt-validate --service name     # Validate specific service
 *   utt-validate --changed          # Validate only changed services
 *   utt-validate --config path      # Use custom config file
 */

const fs = require('fs');
const path = require('path');
const { UniversalValidator } = require('../dist/lib');

// Parse command line arguments
const args = process.argv.slice(2);
const options = {
  service: null,
  changed: false,
  config: '.traceability/config.json',
  help: false
};

for (let i = 0; i < args.length; i++) {
  switch (args[i]) {
    case '--service':
      options.service = args[++i];
      break;
    case '--changed':
      options.changed = true;
      break;
    case '--config':
      options.config = args[++i];
      break;
    case '--help':
    case '-h':
      options.help = true;
      break;
  }
}

if (options.help) {
  console.log(`
Unit-Test-Tracer - Universal Test Validation Tool

Usage:
  utt-validate                    Validate all enabled services
  utt-validate --service <name>   Validate specific service
  utt-validate --changed          Validate only changed services (git diff)
  utt-validate --config <path>    Use custom config file

Options:
  --service <name>    Service name to validate
  --changed          Detect and validate only changed services
  --config <path>    Path to config file (default: .traceability/config.json)
  --help, -h         Show this help message

Examples:
  utt-validate
  utt-validate --service onboarding-service
  utt-validate --changed
  utt-validate --config /path/to/config.json

Exit Codes:
  0  Validation passed
  1  Validation failed (gaps found or errors occurred)
`);
  process.exit(0);
}

async function main() {
  console.log('ðŸ” Unit-Test-Tracer - Starting validation...\n');

  // Load configuration
  const configPath = path.resolve(process.cwd(), options.config);
  
  if (!fs.existsSync(configPath)) {
    console.error(`âŒ Config file not found: ${configPath}`);
    console.error('   Run this command from your project root or specify --config');
    process.exit(1);
  }

  let config;
  try {
    const configContent = fs.readFileSync(configPath, 'utf-8');
    const configData = JSON.parse(configContent);
    
    // Config already in correct format - just use it
    config = {
      projectRoot: configData.projectRoot || process.cwd(),
      services: Array.isArray(configData.services) 
        ? configData.services 
        : Object.entries(configData.services || {}).map(([name, svc]) => ({
            name,
            enabled: svc.enabled !== false,
            path: svc.path,
            language: svc.language,
            testFramework: svc.testFramework,
            testDirectory: svc.testDirectory,
            testPattern: svc.testPattern,
            scenarioFile: svc.scenarioFile,
            requiresServiceRunning: svc.requiresServiceRunning
          })),
      matching: configData.matching,
      reporting: configData.reporting,
      validation: configData.validation
    };
  } catch (error) {
    console.error(`âŒ Failed to load config: ${error instanceof Error ? error.message : String(error)}`);
    process.exit(1);
  }

  // Create validator
  const validator = new UniversalValidator(config);

  try {
    let result;

    if (options.service) {
      console.log(`ðŸ“¦ Validating service: ${options.service}\n`);
      result = await validator.validateByServiceNames([options.service]);
    } else if (options.changed) {
      console.log('ðŸ“¦ Detecting changed services...\n');
      const changedFiles = await getChangedFiles();
      console.log(`   Found ${changedFiles.length} changed file(s)\n`);
      result = await validator.validateChangedServices(changedFiles);
    } else {
      console.log('ðŸ“¦ Validating all enabled services\n');
      result = await validator.validateAll();
    }

    // Generate reports
    await validator.generateReports(result);

    // Display results
    console.log('\n' + '='.repeat(70));
    console.log('ðŸ“Š VALIDATION RESULTS');
    console.log('='.repeat(70) + '\n');

    const { summary } = result;
    
    console.log(`Total Scenarios:    ${summary.totalScenarios}`);
    console.log(`Coverage:           ${summary.coveragePercent}% (${summary.fullyCovered}/${summary.totalScenarios})`);
    console.log(`Fully Covered:      ${summary.fullyCovered}`);
    console.log(`Partially Covered:  ${summary.partiallyCovered}`);
    console.log(`Not Covered:        ${summary.notCovered}`);
    console.log(`Total Unit Tests:   ${summary.totalTests}`);
    console.log(`Orphan Tests:       ${summary.orphanTests}`);
    console.log(`P0 Critical Gaps:   ${summary.p0Gaps}`);
    console.log(`P1 High Priority:   ${summary.p1Gaps}`);
    console.log(`P2 Medium Priority: ${summary.p2Gaps}`);
    console.log(`P3 Low Priority:    ${summary.p3Gaps}`);

    if (result.errors.length > 0) {
      console.log(`\nâš ï¸  Errors:          ${result.errors.length}`);
      result.errors.forEach(err => {
        console.log(`   - ${err.type}: ${err.message}`);
      });
    }

    console.log('\n' + '='.repeat(70));
    
    if (result.success) {
      console.log('âœ… VALIDATION PASSED');
      console.log('='.repeat(70));
      console.log('\nâœ¨ All critical scenarios are covered by unit tests!');
      process.exit(0);
    } else {
      console.log('âŒ VALIDATION FAILED');
      console.log('='.repeat(70));
      
      if (summary.p0Gaps > 0) {
        console.log(`\nðŸš¨ ${summary.p0Gaps} P0 critical gap(s) found!`);
        console.log('   Developer action required: Add missing unit tests');
      }
      
      if (summary.orphanTests > config.validation.maxOrphanTestsWarning) {
        console.log(`\nâš ï¸  Too many orphan tests: ${summary.orphanTests}`);
        console.log('   QA action required: Map tests to scenarios');
      }
      
      console.log(`\nðŸ“‹ View detailed report at: ${config.reporting.outputDirectory}/`);
      process.exit(1);
    }
  } catch (error) {
    console.error('\nâŒ Validation error:', error instanceof Error ? error.message : String(error));
    if (error instanceof Error && error.stack) {
      console.error('\nStack trace:', error.stack);
    }
    process.exit(1);
  }
}

/**
 * Get list of changed files from git
 */
async function getChangedFiles() {
  const { execSync } = require('child_process');
  
  try {
    // Get staged files
    const output = execSync('git diff --cached --name-only --diff-filter=ACM', {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'ignore']
    });
    
    return output.trim().split('\n').filter(Boolean);
  } catch (error) {
    // Fallback: return empty array if git command fails
    console.warn('âš ï¸  Could not detect git changes, validating all services');
    return [];
  }
}

// Run CLI
main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});
