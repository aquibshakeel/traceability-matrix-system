#!/usr/bin/env node

const path = require('path');
const fs = require('fs');

if (fs.existsSync(path.join(__dirname, '../lib/core/AITestCaseGenerator.ts'))) {
  require('ts-node/register');
}

const { AITestCaseGenerator } = require('../lib/core/AITestCaseGenerator');
const { GitChangeDetector } = require('../lib/core/GitChangeDetector');

function parseCommandLineArgs() {
  const args = {
    serviceName: null,
    servicePath: null
  };

  for (let i = 2; i < process.argv.length; i++) {
    const arg = process.argv[i];
    
    if (arg.startsWith('--service-path=')) {
      args.servicePath = arg.split('=')[1];
    } else if (!arg.startsWith('--')) {
      // First non-flag argument is the service name
      args.serviceName = arg;
    }
  }

  return args;
}

async function main() {
  console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë         ü§ñ AI Test Case Generator (Simple One-Liner Format)          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`);

  const apiKey = process.env.CLAUDE_API_KEY || process.env.ANTHROPIC_API_KEY;
  if (!apiKey) {
    console.error('‚ùå ERROR: Claude API key required!');
    console.error('Set: export CLAUDE_API_KEY="sk-ant-..."');
    process.exit(1);
  }

  const projectRoot = process.cwd();
  const configPath = path.join(projectRoot, '.traceability/config.json');

  if (!fs.existsSync(configPath)) {
    console.error('‚ùå ERROR: Config not found:', configPath);
    process.exit(1);
  }

  const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
  
  // Parse command-line arguments
  const cliArgs = parseCommandLineArgs();
  
  // Prepare CLI overrides for PathResolver (if needed in future)
  const cliOverrides = {
    servicePath: cliArgs.servicePath
  };
  
  const generator = new AITestCaseGenerator(apiKey, projectRoot, config, cliOverrides);
  
  // Check if specific service was provided as argument
  const targetServiceName = cliArgs.serviceName;
  
  // Detect which services have changes
  const gitDetector = new GitChangeDetector(projectRoot);
  const servicePaths = config.services.filter(s => s.enabled).map(s => s.path);
  const gitAnalysis = await gitDetector.detectChanges(servicePaths);
  
  // Filter services to analyze
  let servicesToProcess = config.services.filter(s => s.enabled);
  
  if (targetServiceName) {
    // MANUAL EXECUTION: Specific service requested ‚Üí ALWAYS generate (ignore Git)
    console.log(`\nüìå Manual execution - generating for: ${targetServiceName}`);
    servicesToProcess = servicesToProcess.filter(s => s.name === targetServiceName);
    
    if (servicesToProcess.length === 0) {
      console.error(`\n‚ùå ERROR: Service '${targetServiceName}' not found or not enabled`);
      console.error(`\nAvailable services: ${config.services.map(s => s.name).join(', ')}`);
      process.exit(1);
    }
    
    // If CLI service path provided, override the service path
    if (cliArgs.servicePath && servicesToProcess.length > 0) {
      console.log(`\nüéØ CLI Override: Service Path = ${cliArgs.servicePath}`);
      servicesToProcess[0].path = cliArgs.servicePath;
    }
  } else {
    // PRE-COMMIT MODE: No service specified ‚Üí Use Git detection
    if (gitAnalysis.affectedServices.length > 0) {
      console.log(`\nüìå Pre-commit mode - generating for changed services: ${gitAnalysis.affectedServices.join(', ')}`);
      servicesToProcess = servicesToProcess.filter(s => 
        gitAnalysis.affectedServices.includes(s.name)
      );
    } else {
      console.log(`\nüìå No service code changes detected - skipping generation`);
      console.log('‚úÖ No services to process');
      return;
    }
  }

  if (servicesToProcess.length === 0) {
    console.log('\n‚úÖ No services to process');
    return;
  }

  for (const service of servicesToProcess) {
    try {
      await generator.generate(service);
    } catch (error) {
      console.error(`\n‚ùå Failed: ${service.name}:`, error.message);
      if (process.env.VERBOSE) {
        console.error(error.stack);
      }
    }
  }

  console.log(`
‚úÖ Generation complete!
üìÅ AI cases: .traceability/ai_cases/
üìù QA baseline: .traceability/test-cases/baseline/

Next: Review AI cases and copy relevant üÜï scenarios to baseline
`);
}

main().catch(error => {
  console.error('\n‚ùå Fatal error:', error.message);
  if (process.env.VERBOSE) {
    console.error(error.stack);
  }
  process.exit(1);
});
