#!/usr/bin/env node

const path = require('path');
const fs = require('fs');
const { execSync } = require('child_process');

if (fs.existsSync(path.join(__dirname, '../lib/core/AITestCaseGenerator.ts'))) {
  require('ts-node/register');
}

const { AITestCaseGenerator } = require('../lib/core/AITestCaseGenerator');
const { GitChangeDetector } = require('../lib/core/GitChangeDetector');

async function main() {
  console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë         ü§ñ AI Test Case Generator (Simple One-Liner Format)          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`);

  const apiKey = process.env.CLAUDE_API_KEY || process.env.ANTHROPIC_API_KEY;
  if (!apiKey) {
    console.error('‚ùå ERROR: Claude API key required!');
    console.error('Set: export CLAUDE_API_KEY="sk-ant-..."');
    process.exit(1);
  }

  const projectRoot = process.cwd();
  const configPath = path.join(projectRoot, '.traceability/config.json');

  if (!fs.existsSync(configPath)) {
    console.error('‚ùå ERROR: Config not found:', configPath);
    process.exit(1);
  }

  const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
  const generator = new AITestCaseGenerator(apiKey, projectRoot);
  
  // Detect which services have changes
  const gitDetector = new GitChangeDetector(projectRoot);
  const servicePaths = config.services.map(s => s.path);
  const gitAnalysis = await gitDetector.detectChanges(servicePaths);
  
  // Filter services to only those with changes
  let servicesToProcess = config.services.filter(s => s.enabled);
  
  if (gitAnalysis.affectedServices.length > 0) {
    console.log(`\nüìå Only analyzing changed services: ${gitAnalysis.affectedServices.join(', ')}`);
    servicesToProcess = servicesToProcess.filter(s => 
      gitAnalysis.affectedServices.includes(s.name)
    );
  } else {
    console.log(`\nüìå No service code changes detected - skipping analysis`);
    console.log('‚úÖ No services to process');
    return;
  }

  if (servicesToProcess.length === 0) {
    console.log('\n‚úÖ No services to process');
    return;
  }

  for (const service of servicesToProcess) {
    try {
      await generator.generate(service);
    } catch (error) {
      console.error(`\n‚ùå Failed: ${service.name}:`, error.message);
    }
  }

  console.log(`
‚úÖ Generation complete!
üìÅ AI cases: .traceability/test-cases/ai_cases/
üìù QA baseline: .traceability/test-cases/baseline/

Next: Review AI cases and copy relevant üÜï scenarios to baseline
`);
}

main().catch(error => {
  console.error('\n‚ùå Fatal error:', error);
  process.exit(1);
});
