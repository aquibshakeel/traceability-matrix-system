#!/usr/bin/env node

const path = require('path');
const fs = require('fs');

if (fs.existsSync(path.join(__dirname, '../lib/core/EnhancedCoverageAnalyzer.ts'))) {
  require('ts-node/register');
}

const { EnhancedCoverageAnalyzer } = require('../lib/core/EnhancedCoverageAnalyzer');
const { GitChangeDetector } = require('../lib/core/GitChangeDetector');
const { ReportGenerator } = require('../lib/core/ReportGenerator');
const { HistoryManager } = require('../lib/core/HistoryManager');

async function main() {
  console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë          üìä AI-Powered Coverage Analyzer & Reporter                  ‚ïë
‚ïë     Orphan Categorization | Git Changes | Multi-Format Reports       ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`);

  const apiKey = process.env.CLAUDE_API_KEY || process.env.ANTHROPIC_API_KEY;
  if (!apiKey) {
    console.error('‚ùå ERROR: Claude API key required!');
    console.error('   Set: export CLAUDE_API_KEY="sk-ant-..."');
    process.exit(1);
  }

  const projectRoot = process.cwd();
  const configPath = path.join(projectRoot, '.traceability/config.json');

  if (!fs.existsSync(configPath)) {
    console.error('‚ùå ERROR: Config not found:', configPath);
    process.exit(1);
  }

  const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
  
  // Initialize PathResolver for logging
  const { PathResolver } = require('../lib/utils/PathResolver');
  const pathResolver = new PathResolver(projectRoot, config);
  
  // Log path configuration
  console.log('\nüìÅ Path Configuration:');
  const pathSummary = pathResolver.getPathConfigSummary();
  pathSummary.forEach(line => console.log(`   ${line}`));
  
  const analyzer = new EnhancedCoverageAnalyzer(apiKey, projectRoot, config);
  const gitDetector = new GitChangeDetector(projectRoot);
  const reportGenerator = new ReportGenerator(projectRoot);
  const historyManager = new HistoryManager(projectRoot);

  // Get current commit info for history tracking
  const commitInfo = historyManager.getCommitInfo();
  
  // Check if specific service was provided as argument
  const targetServiceName = process.argv[2];
  
  // Detect Git changes (only used when no specific service specified)
  const servicePaths = config.services.filter(s => s.enabled).map(s => s.path);
  const gitChanges = await gitDetector.detectChanges(servicePaths);

  // Filter services to analyze
  let servicesToAnalyze = config.services.filter(s => s.enabled);
  
  if (targetServiceName) {
    // MANUAL EXECUTION: Specific service requested ‚Üí ALWAYS analyze (ignore Git)
    console.log(`\nüìå Manual execution - analyzing: ${targetServiceName}`);
    servicesToAnalyze = servicesToAnalyze.filter(s => s.name === targetServiceName);
    
    if (servicesToAnalyze.length === 0) {
      console.error(`\n‚ùå ERROR: Service '${targetServiceName}' not found or not enabled`);
      console.error(`\nAvailable services: ${config.services.map(s => s.name).join(', ')}`);
      process.exit(1);
    }
  } else {
    // PRE-COMMIT MODE: No service specified ‚Üí Use Git detection
    if (gitChanges.affectedServices.length > 0) {
      console.log(`\nüìå Pre-commit mode - analyzing changed services: ${gitChanges.affectedServices.join(', ')}`);
      servicesToAnalyze = servicesToAnalyze.filter(s => 
        gitChanges.affectedServices.includes(s.name)
      );
    } else {
      console.log(`\nüìå Pre-commit mode - no service code changes detected`);
      console.log('‚úÖ No services to process');
      return;
    }
  }

  if (servicesToAnalyze.length === 0) {
    console.log('\n‚úÖ No services to analyze');
    process.exit(0);
  }

  let allAnalyses = [];
  let hasP0Gaps = false;
  let hasP1Gaps = false;

  // Analyze each service
  for (const service of servicesToAnalyze) {
    try {
      const analysis = await analyzer.analyze(service);
      allAnalyses.push(analysis);

      // Check for critical gaps
      if (analysis.summary.p0Gaps > 0) {
        hasP0Gaps = true;
      }
      if (analysis.summary.p1Gaps > 0) {
        hasP1Gaps = true;
      }

      // Generate reports (HTML, JSON, CSV, Markdown)
      const reports = await reportGenerator.generateReports(
        analysis,
        gitChanges,
        {
          formats: ['html', 'json', 'csv', 'markdown'],
          outputDir: '.traceability/reports',
          serviceName: service.name,
          openHtmlAutomatically: true
        }
      );

      console.log(`\n‚úÖ Generated ${reports.length} reports for ${service.name}`);
      
      // üìä HISTORY TRACKING - Store persistent data
      console.log(`üìä Updating history for ${service.name}...`);
      
      // 1. Append coverage trend
      historyManager.appendCoverageTrend(
        service.name,
        analysis.coveragePercent,
        analysis.summary.fullyCovered,
        analysis.summary.totalScenarios,
        analysis.summary.p0Gaps,
        analysis.summary.p1Gaps,
        commitInfo?.commit
      );
      
      // 2. Append git changes (if any for this service)
      const serviceApiChanges = gitChanges.apiChanges.filter(change => 
        change.file.includes(service.path)
      );
      
      if (serviceApiChanges.length > 0) {
        historyManager.appendGitChanges(
          service.name,
          serviceApiChanges,
          commitInfo?.commit,
          commitInfo?.author,
          commitInfo?.message
        );
        
        // 3. Update API risk scores
        historyManager.updateAPIRiskScores(service.name, serviceApiChanges);
        console.log(`  ‚úÖ Recorded ${serviceApiChanges.length} API change(s) to history`);
      }

    } catch (error) {
      console.error(`\n‚ùå Failed: ${service.name}:`, error.message);
      if (process.env.VERBOSE) {
        console.error(error.stack);
      }
    }
  }

  // Final summary
  console.log('\n' + '='.repeat(70));
  console.log('üìã FINAL SUMMARY');
  console.log('='.repeat(70));

  const totalP0Gaps = allAnalyses.reduce((sum, a) => sum + a.summary.p0Gaps, 0);
  const totalP1Gaps = allAnalyses.reduce((sum, a) => sum + a.summary.p1Gaps, 0);
  const totalP2Gaps = allAnalyses.reduce((sum, a) => sum + a.summary.p2Gaps, 0);
  const avgCoverage = allAnalyses.length > 0 
    ? allAnalyses.reduce((sum, a) => sum + a.coveragePercent, 0) / allAnalyses.length 
    : 0;

  console.log(`Services Analyzed: ${allAnalyses.length}`);
  console.log(`Average Coverage: ${avgCoverage.toFixed(1)}%`);
  console.log(`Total Gaps: P0=${totalP0Gaps}, P1=${totalP1Gaps}, P2=${totalP2Gaps}`);

  if (gitChanges.summary.apisWithoutTests > 0) {
    console.log(`\n‚ö†Ô∏è  WARNING: ${gitChanges.summary.apisWithoutTests} new APIs without tests!`);
  }

  // CRITICAL: Check for orphan unit tests (tests without baseline scenarios)
  let totalOrphanBusinessTests = 0;
  let criticalOrphanTests = 0;
  let orphanAPIs = 0;
  
  for (const analysis of allAnalyses) {
    totalOrphanBusinessTests += analysis.orphanTests.businessTests.length;
    orphanAPIs += analysis.orphanAPIs.length;
    
    // Count P0/P1 orphan tests
    criticalOrphanTests += analysis.orphanTests.businessTests.filter(
      t => t.orphanCategory?.priority === 'P0' || t.orphanCategory?.priority === 'P1'
    ).length;
  }

  // Build failure reasons
  const failures = [];
  
  if (hasP0Gaps) {
    failures.push(`‚ùå P0 Gaps: ${totalP0Gaps} critical baseline scenarios have NO unit tests`);
  }
  
  if (hasP1Gaps && config.preCommit?.blockOnP1Gaps) {
    failures.push(`‚ùå P1 Gaps: ${totalP1Gaps} high-priority baseline scenarios have NO unit tests`);
  }
  
  if (criticalOrphanTests > 0) {
    failures.push(`‚ùå Orphan Tests: ${criticalOrphanTests} P0/P1 unit tests exist but have NO baseline scenarios`);
  }
  
  if (orphanAPIs > 0) {
    failures.push(`‚ùå Orphan APIs: ${orphanAPIs} API endpoint(s) have NO baseline scenarios AND NO unit tests`);
  }

  // Exit with appropriate code
  if (failures.length > 0) {
    console.log('\n' + '='.repeat(70));
    console.log('‚ùå VALIDATION FAILED - COMMIT BLOCKED');
    console.log('='.repeat(70));
    console.log('');
    
    failures.forEach(failure => console.log(failure));
    
    console.log('\nüìã Required Actions:');
    console.log('');
    
    if (hasP0Gaps || hasP1Gaps) {
      console.log('1. üî¥ Coverage Gaps:');
      console.log('   - Review baseline scenarios marked as "NOT_COVERED"');
      console.log('   - Implement unit tests for each scenario');
      console.log('   - Prioritize P0 (auth, security) and P1 (error handling)');
      console.log('');
    }
    
    if (criticalOrphanTests > 0) {
      console.log('2. üîç Orphan Unit Tests:');
      console.log('   - Review "Orphan Tests" section in HTML report');
      console.log('   - QA Action: Add missing scenarios to baseline YAML');
      console.log('   - Use the "Copy-Ready YAML Format" in report for easy addition');
      console.log('   - These tests cover business logic but lack documentation');
      console.log('');
    }
    
    if (orphanAPIs > 0) {
      console.log('3. ‚ö†Ô∏è  Orphan APIs:');
      console.log('   - Review "Orphan APIs" section in HTML report');
      console.log('   - QA Action: Create baseline scenarios for these endpoints');
      console.log('   - Dev Action: Implement unit tests after scenarios are added');
      console.log('   - These are discovered APIs with zero coverage');
      console.log('');
    }
    
    console.log('üí° Tips:');
    console.log('   ‚Ä¢ Open HTML report (auto-opened) for detailed analysis');
    console.log('   ‚Ä¢ Check .traceability/reports/ for all report formats');
    console.log('   ‚Ä¢ Use git commit --no-verify to skip (NOT recommended)');
    console.log('');
    
    process.exit(1);
  }

  console.log('\n‚úÖ Analysis complete! All reports generated.');
  
  // Success message with warnings if any non-critical issues
  if (totalOrphanBusinessTests > criticalOrphanTests && totalOrphanBusinessTests > 0) {
    console.log(`\n‚ö†Ô∏è  Note: ${totalOrphanBusinessTests - criticalOrphanTests} P2/P3 orphan tests detected (not blocking)`);
    console.log('   Consider adding scenarios for better traceability');
  }
  
  process.exit(0);
}

main().catch(error => {
  console.error('\n‚ùå Fatal error:', error.message);
  if (process.env.VERBOSE) {
    console.error(error.stack);
  }
  process.exit(1);
});
